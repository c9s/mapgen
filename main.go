package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"os"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	log "github.com/sirupsen/logrus"

	"golang.org/x/tools/go/packages"
)

var (
	typeName     = flag.String("type", "", "Type name to parse constants from; required")
	output       = flag.String("output", "", "Output file name; default: <type>map.go")
	outputStdout = flag.Bool("stdout", false, "Output generated content to stdout")
	noFormat     = flag.Bool("noFormat", false, "Disable formatting of generated code; default: false")
)

type ConstantInfo struct {
	TypeName       string
	TypeValue      types.TypeAndValue
	UnderlyingType types.Type

	Constants []string
	Groups    map[string][]string

	HasIntValues bool
	IsInt        bool // true if type is int, int32, int64
}

type Generator struct {
	pkg          *packages.Package
	Type         string
	constantInfo ConstantInfo
	outputBuffer bytes.Buffer
}

func main() {
	flag.Parse()

	if *typeName == "" {
		fmt.Println("Error: -type is required")
		os.Exit(1)
	}

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}

	// Load the current package
	pkgs, err := loadPackages(args[0])
	if err != nil {
		log.Errorf("Error loading package: %v", err)
		os.Exit(1)
	}

	if len(pkgs) != 1 {
		fmt.Println("Error: Expected a single package")
		os.Exit(1)
	}

	gen := Generator{
		pkg:  pkgs[0],
		Type: *typeName,
		constantInfo: ConstantInfo{
			TypeName:  *typeName,
			Constants: []string{},
			Groups:    map[string][]string{},
		},
	}

	gen.parseConstants()

	var outputFile string
	if *outputStdout {
		if err := gen.generateCode(os.Stdout); err != nil {
			log.Errorf("error generating code: %v", err)
			os.Exit(1)
		}
	} else {
		outputFile = *output
		if outputFile == "" {
			outputFile = fmt.Sprintf("%smap.go", strings.ToLower(*typeName))
		}

		file, err := os.Create(outputFile)
		if err != nil {
			log.Errorf("error creating output file: %v", err)
			os.Exit(1)
		}

		defer file.Close()

		if err := gen.generateCode(file); err != nil {
			log.Errorf("error generating code: %v", err)
			os.Exit(1)
		}
	}

	if !*outputStdout {
		log.Infof("generated file: %s", outputFile)
	}
}

func loadPackages(pattern string) ([]*packages.Package, error) {
	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedTypes |
			packages.NeedSyntax |
			packages.NeedImports |
			packages.NeedTypesInfo,
	}

	return packages.Load(cfg, pattern)
}

func toTitleCase(input string) string {
	if len(input) == 0 {
		return input
	}
	runes := []rune(input)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func (g *Generator) parseConstants() {
	groupRegex := regexp.MustCompile(`^//\s*@group\s+(\S+)`)

	var typeSet bool

	for _, file := range g.pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			decl, ok := n.(*ast.GenDecl)
			if !ok || decl.Tok != token.CONST {
				return true
			}

			log.Debugf("found const decl %+v", decl)

			var currentGroup string

			for _, spec := range decl.Specs {
				valueSpec, ok := spec.(*ast.ValueSpec)
				if !ok || len(valueSpec.Names) == 0 {
					continue
				}

				if valueSpec.Type == nil {
					continue
				}

				ident, ok := valueSpec.Type.(*ast.Ident)
				if !ok || ident.Name != g.constantInfo.TypeName {
					continue
				}

				typeAndValue, ok := g.pkg.TypesInfo.Types[valueSpec.Type]
				if ok {
					log.Infof("found typeAndValue for %s: %v, underlying type: %v", valueSpec.Type, typeAndValue, typeAndValue.Type.Underlying())
				}

				if !typeSet {
					g.constantInfo.TypeValue = typeAndValue
					g.constantInfo.UnderlyingType = typeAndValue.Type.Underlying()

					// judge if type is int, int32, int64 using switch
					switch a := g.constantInfo.UnderlyingType.(type) {
					case *types.Basic:
						switch a.Kind() {
						case types.Int, types.Int8, types.Int16, types.Int32, types.Int64:
							g.constantInfo.HasIntValues = true
							g.constantInfo.IsInt = true
						default:
						}
					default:
					}

					typeSet = true
				}

				// Check for @group annotations
				doc := decl.Doc
				if doc == nil {
					doc = valueSpec.Doc
				}
				if doc != nil {
					for _, comment := range doc.List {
						matches := groupRegex.FindStringSubmatch(comment.Text)
						if len(matches) == 2 {
							currentGroup = toTitleCase(strings.TrimSpace(matches[1]))
						}
					}
				}

				// Collect constants
				for _, name := range valueSpec.Names {
					constName := name.Name
					g.constantInfo.Constants = append(g.constantInfo.Constants, constName)
					if currentGroup != "" {
						g.constantInfo.Groups[currentGroup] = append(g.constantInfo.Groups[currentGroup], constName)
					}
				}
			}

			return true
		})
	}
}

func (g *Generator) generateCode(output *os.File) error {
	const templateText = `// Code generated by go:generate; DO NOT EDIT.
package {{.PkgName}}

{{ if .Info.HasIntValues }}
import "fmt"
{{ end }}

var All{{.Type}}s = map[{{.Type}}]struct{}{
{{- range .Constants }}
	{{.}}: {},
{{- end }}
}

{{- range $group, $constants := .Groups }}
var All{{$group}}{{$.Type}}s = map[{{$.Type}}]struct{}{
{{- range $constants }}
	{{.}}: {},
{{- end }}
}

// All{{$group}}{{$.Type}}sKeys converts the {{$group}} group map of {{$.Type}} to a slice of {{$.Type}}
func All{{$group}}{{$.Type}}sKeys() []{{$.Type}} {
	keys := make([]{{$.Type}}, 0, len(All{{$group}}{{$.Type}}s))
	for k := range All{{$group}}{{$.Type}}s {
		keys = append(keys, k)
	}
	return keys
}

// Validate{{$group}}{{$.Type}}s validates if a value belongs to the {{$group}} group of {{$.Type}}
func Validate{{$group}}{{$.Type}}s(ch {{$.Type}}) bool {
	_, ok := All{{$group}}{{$.Type}}s[ch]
	return ok
}

// Is{{$group}}{{$.Type}} checks if the value is in the {{$group}} group of {{$.Type}}
func Is{{$group}}{{$.Type}}(ch {{$.Type}}) bool {
	_, exist := All{{$group}}{{$.Type}}s[ch]
	return exist
}
{{- end }}

var All{{.Type}}sSlice = []{{.Type}}{
{{- range .Constants }}
	{{.}},
{{- end }}
}

func {{.Type}}Strings(slice []{{.Type}}) (out []{{if .Info.HasIntValues }}int{{else}}string{{end}}) {
	for _, el := range slice {
		{{- if .Info.HasIntValues -}}
		out = append(out, fmt.Sprintf("%d", el))
		{{- else }}
		out = append(out, string(el))
		{{- end }}
	}
	return out
}

// {{.Type}}Keys converts a map of {{.Type}} to a slice of {{.Type}}
func {{.Type}}Keys(values map[{{.Type}}]struct{}) (slice []{{.Type}}) {
	for k := range values {
		slice = append(slice, k)
	}
	return slice
}

// Validate{{.Type}} validates a value of type {{.Type}}
func Validate{{.Type}}(ch {{.Type}}) bool {
	_, ok := All{{.Type}}s[ch]
	return ok
}
`

	tmpl, err := template.New("code").Parse(templateText)
	if err != nil {
		return fmt.Errorf("error parsing template: %v", err)
	}

	data := struct {
		PkgName   string
		Type      string
		Constants []string
		Info      ConstantInfo
		Groups    map[string][]string
	}{
		PkgName:   g.pkg.Name,
		Info:      g.constantInfo,
		Type:      g.constantInfo.TypeName,
		Constants: g.constantInfo.Constants,
		Groups:    g.constantInfo.Groups,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("error generating template: %w", err)
	}

	if !*noFormat {
		// Use go/format to format the generated source code
		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("error formatting source: %w", err)
		}

		// Write the formatted source code to the output file
		if _, err := output.Write(formatted); err != nil {
			return fmt.Errorf("error writing to output: %w", err)
		}
	} else {
		if _, err := output.Write(buf.Bytes()); err != nil {
			return fmt.Errorf("error writing to output: %w", err)
		}
	}

	return nil
}
